# 十一、以太坊多币钟钱包原理
## 1、以太坊数字货币种类
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以太坊上的数字货币大体可以分为两类，一类是原币，即以太坊区块本身所代表的数字资产，又称以太币；另一类是通过在以太坊上部署合约，合约内部设置一个 mapping 对象来存储不同地址资产的代币。<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，代币也要再细分一下种类。遵循 ERC20 标准的代币，这样的代币具有相同的执行交易、获取余额、授权交易等方法，可以由一套钱包代码来驱动，可以规结为 ERC20 类型的代币。以及未遵循该规范的代币，此种类型代币包含哪些 API，如何进行交易、获取余额等，互相之间都是不同的，需要查找官方资料，并对该类型的每种币进行针对开发。<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节，只针对原币，及基于 ERC20 标准的多币种钱包原理进行讲解。

## 2、原币交易
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原币交易，需要将交易信息封装成如下对象，`0x` 开头的皆为 16进制形式：

```
var rawTx = {
    "nonce": "0x0c",
    "gasPrice": "0x098bca5a00",
    "gasLimit": "0x5208",
    "to": "0xDc73018EC5d11616a3EEFfc9421E79ee5225023d",
    "value": "0x0de0b6b3a7640000",
    "data": "0x",
    "chainId": 1
}
```

- `nonce`：为防止交易重播，ETH（ETC）节点要求每笔交易必须有一个 nonce 数值。每一个账户从同一个节点发起交易时，这个 nonce 值从0开始计数，发送一笔 nonce 对应加 1。当前面的 nonce 处理完成之后才会处理后面的 nonce。可调用 RPC `eth_getTransactionCount` 来获取。 <br/>
- `gasPrice`：gas 对 以太币价格，可以调用 RPC `eth_gasPrice` 来查询<br/>
- `gasLimit`：提供的手续费<br/>
- `to`：接收以太币地址<br/>
- `value`：发送的以太币数量<br/> 
- `data`：可忽略，用于代币交易时的合约相关参数<br/>
- `chainId`：当前链 ID<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再通过如下方式进行签名，并做序列化：

```
var Tx = require('ethereumjs-tx');
var eTx = new Tx(rawTx);
eTx.sign(new Buffer('<your-private-key>', 'hex'));
var signedTx = '0x' + eTx.serialize().toString('hex');
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`ethereumjs-tx` 需要通过 npm 或 yarn 安装，这里以 yarn 为例：

```
yarn add ethereumjs-tx
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再

```
var data = {
    id: randomId,
    jsonrpc: "2.0",
    method: 'eth_sendRawTransaction',
    params: [signedTx]
}
```
- method: 'eth_sendRawTransaction'，查阅 [json rpc api](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sendrawtransaction)，发现还有一个 method 与之比较相近，是 `eth_sendTransaction`，该方法是连接到相邻结节，并使用所连结节的账户发送交易，而 `eth_sendRawTransaction` 是使用当前账户地址发送交易。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外 randomId：

```
var crypto = require(crypto);
var randomId = crypto.randomBytes(16).toString('hex');
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终向网络发送交易

```
this.SERVERURL = https://api.myetherapi.com/eth || http://localhost:8545;
this.config = {
    headers: {
        'Content-Type': 'application/json; charset=UTF-8'
    }
}
$http.post(this.SERVERURL, JSON.stringify(data), this.config).then(function (data) {
    callback(data.data);
}, function (data) {
    callback({error: true, msg: "connection error", data: ""});
});
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里 `$http.post` 为 Angular $HttpProvider 写法，小伙伴可自行将其改换为其他 ajax 请求。


## 3、代币交易
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代币交易需要将数据封装成下面的格式，0x 开头的皆为 16进制形式：

```
var rawTx = {
    "nonce": "0x0f",
    "gasPrice": "0x098bca5a00",
    "gasLimit": "0xc971",
    "to": "0x43c437951aa920397106640537014c32a93b8f2d",
    "value": "0x00",
    "data": "0xa9059cbb00000000000000000000000039acbef4ad293ccd50913985ed688d27c5dc565000000000000000000000000000000000000000000000000000000000000003e8",
    "chainId": 1
}
```

- `nonce`：<br/>
- `gasPrice`：<br/>
- `gasLimit`：以上，同原币交易<br/>
- `to`：与原币交易不同，此时的 to，为代币的合约地址，切记！<br/>
- `value`：以太币交易数量，因为本次是代币交易，所以以太币交易数量是 0<br/> 
- `data`：要执行的合约方法，参数等。计算方法：`0x` + `function signature` + 参数（每个参数要补全 64位）<br/>
- `chainId`：当前链 ID<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要调用以太坊合约方法，必须仍旧使用以太坊链自带的 `eth_call` 及 `eth_sendRawTransaction` 方法，前者只用于查看，如 `balanceOf`，后者用于更新，如 `transfer`，而合约方法名和参数则由 params 来体现。

### 代币 function signature
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此处我们要调用合约中的 transfer 方法，首先查看 transfer 函数的实现：

```
function transfer(address _to, uint _value) public returns (bool);
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提炼出函数原型

```
transfer(address,uint256)
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 geth 控制台下运行命令：

```
web3.sha3('transfer(address,uint256)').substring(2,10)
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的过程也可以用 web3.js 工具完成

```
var functionSig = web3.sha3("transfer(address,uint256)").substr(2,10)
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到函数hash：a9059cbb<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外也可以把 contract code 贴到 remix，在合约的 Details 中可以看到完整的合约方法和对应的 function signature。

<center>![合约Details][contract-detail]</center>

### 函数参数
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设收款人地址："0x39acbef4ad293ccd50913985ed688d27c5dc5650"，交易代币 1000。

- 第一个参数，去掉前面的 "0x"，并在左边补24个零(一般地址长度为42位, 去掉'0x'后为40位)，构成64位十六进制参数：00000000000000000000000039acbef4ad293ccd50913985ed688d27c5dc5650。
- 第二个参数，1000 化为 16进制 '0x3e8'后，去 '0x'，补 '0' 到 64位：00000000000000000000000000000000000000000000000000000000000003e8

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将以上信息连起来得：'0x' + 'a9059cbb' + '00000000000000000000000039acbef4ad293ccd50913985ed688d27c5dc5650' + '00000000000000000000000000000000000000000000000000000000000003e8' 最终得到函数参数：0xa9059cbb00000000000000000000000039acbef4ad293ccd50913985ed688d27c5dc565000000000000000000000000000000000000000000000000000000000000003e8，这就是上面的 data 参数值。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后，同样需要对交易进行签名，和序列化：

```
var Tx = require('ethereumjs-tx');
var eTx = new Tx(rawTx);
eTx.sign(new Buffer('<your-private-key>', 'hex'));
var signedTx = '0x' + eTx.serialize().toString('hex');
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再

```
var data = {
    id: randomId,
    jsonrpc: "2.0",
    method: 'eth_sendRawTransaction',
    params: [signedTx]
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终向网络发送交易

```
this.SERVERURL = https://api.myetherapi.com/eth || http://localhost:8545;
this.config = {
    headers: {
        'Content-Type': 'application/json; charset=UTF-8'
    }
}
$http.post(this.SERVERURL, JSON.stringify(data), this.config).then(function (data) {
    callback(data.data);
}, function (data) {
    callback({error: true, msg: "connection error", data: ""});
});
```


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


[contract-detail]:























